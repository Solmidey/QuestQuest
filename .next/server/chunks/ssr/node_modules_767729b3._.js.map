{"version":3,"sources":["../../../../node_modules/%40noble/curves/src/abstract/utils.ts","../../../../node_modules/viem/utils/address/isAddressEqual.ts","../../../../node_modules/viem/utils/abi/encodeFunctionResult.ts","../../../../node_modules/viem/utils/abi/decodeFunctionData.ts","../../../../node_modules/viem/utils/abi/encodeErrorResult.ts","../../../../node_modules/viem/utils/ens/localBatchGatewayRequest.ts"],"sourcesContent":["/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nexport function abytes(item: unknown): void {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean =\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\nconst u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr: ArrayLike<number>) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n  InvalidArrayError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionName,\n  ContractFunctionReturnType,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionResult'\n\nexport type EncodeFunctionResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n  result?:\n    | ContractFunctionReturnType<\n        abi,\n        AbiStateMutability,\n        functionName extends ContractFunctionName<abi>\n          ? functionName\n          : ContractFunctionName<abi>,\n        never // allow all args. required for overloads to work.\n      >\n    | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | undefined }\n      : { functionName: functionName | allFunctionNames }\n    : { functionName?: functionName | allFunctionNames | undefined }\n> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionResultReturnType = Hex\n\nexport type EncodeFunctionResultErrorType =\n  | AbiFunctionOutputsNotFoundError\n  | AbiFunctionNotFoundError\n  | EncodeAbiParametersErrorType\n  | GetAbiItemErrorType\n  | ErrorType\n\nexport function encodeFunctionResult<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionResultParameters<abi, functionName>,\n): EncodeFunctionResultReturnType {\n  const { abi, functionName, result } =\n    parameters as EncodeFunctionResultParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({ abi, name: functionName })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  if (!abiItem.outputs)\n    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath })\n\n  const values = (() => {\n    if (abiItem.outputs.length === 0) return []\n    if (abiItem.outputs.length === 1) return [result]\n    if (Array.isArray(result)) return result\n    throw new InvalidArrayError(result)\n  })()\n\n  return encodeAbiParameters(abiItem.outputs, values)\n}\n","import type { Abi, AbiStateMutability } from 'abitype'\n\nimport { AbiFunctionSignatureNotFoundError } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = {\n  abi: abi\n  data: Hex\n}\n\nexport type DecodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allFunctionNames extends\n    ContractFunctionName<abi> = ContractFunctionName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? UnionEvaluate<\n      {\n        [functionName in allFunctionNames]: {\n          args: ContractFunctionArgs<abi, AbiStateMutability, functionName>\n          functionName: functionName\n        }\n      }[allFunctionNames]\n    >\n  : {\n      args: readonly unknown[] | undefined\n      functionName: string\n    }\n\nexport type DecodeFunctionDataErrorType =\n  | AbiFunctionSignatureNotFoundError\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | SliceErrorType\n  | ErrorType\n\nexport function decodeFunctionData<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeFunctionDataParameters<abi>,\n) {\n  const { abi, data } = parameters as DecodeFunctionDataParameters\n  const signature = slice(data, 0, 4)\n  const description = abi.find(\n    (x) =>\n      x.type === 'function' &&\n      signature === toFunctionSelector(formatAbiItem(x)),\n  )\n  if (!description)\n    throw new AbiFunctionSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeFunctionData',\n    })\n  return {\n    functionName: (description as { name: string }).name,\n    args: ('inputs' in description &&\n    description.inputs &&\n    description.inputs.length > 0\n      ? decodeAbiParameters(description.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n  } as DecodeFunctionDataReturnType<abi>\n}\n","import type { Abi, ExtractAbiErrors } from 'abitype'\n\nimport {\n  AbiErrorInputsNotFoundError,\n  AbiErrorNotFoundError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractErrorArgs,\n  ContractErrorName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeErrorResult'\n\nexport type EncodeErrorResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  errorName extends ContractErrorName<abi> | undefined = ContractErrorName<abi>,\n  ///\n  hasErrors = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiErrors<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractErrorArgs<\n    abi,\n    errorName extends ContractErrorName<abi>\n      ? errorName\n      : ContractErrorName<abi>\n  >,\n  allErrorNames = ContractErrorName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { errorName?: errorName | allErrorNames | undefined }\n      : { errorName: errorName | allErrorNames }\n    : { errorName?: errorName | allErrorNames | undefined }\n> &\n  (hasErrors extends true ? unknown : never)\n\nexport type EncodeErrorResultReturnType = Hex\n\nexport type EncodeErrorResultErrorType =\n  | GetAbiItemErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | EncodeAbiParametersErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function encodeErrorResult<\n  const abi extends Abi | readonly unknown[],\n  errorName extends ContractErrorName<abi> | undefined = undefined,\n>(\n  parameters: EncodeErrorResultParameters<abi, errorName>,\n): EncodeErrorResultReturnType {\n  const { abi, errorName, args } = parameters as EncodeErrorResultParameters\n\n  let abiItem = abi[0]\n  if (errorName) {\n    const item = getAbiItem({ abi, args, name: errorName })\n    if (!item) throw new AbiErrorNotFoundError(errorName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'error')\n    throw new AbiErrorNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toFunctionSelector(definition)\n\n  let data: Hex = '0x'\n  if (args && args.length > 0) {\n    if (!abiItem.inputs)\n      throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath })\n    data = encodeAbiParameters(abiItem.inputs, args)\n  }\n  return concatHex([signature, data])\n}\n","import { batchGatewayAbi } from '../../constants/abis.js'\nimport { solidityError } from '../../constants/solidity.js'\nimport type { Hex } from '../../types/misc.js'\nimport { decodeFunctionData } from '../abi/decodeFunctionData.js'\nimport { encodeErrorResult } from '../abi/encodeErrorResult.js'\nimport { encodeFunctionResult } from '../abi/encodeFunctionResult.js'\nimport type {\n  CcipRequestErrorType,\n  CcipRequestParameters,\n  CcipRequestReturnType,\n} from '../ccip.js'\n\nexport const localBatchGatewayUrl = 'x-batch-gateway:true'\n\nexport async function localBatchGatewayRequest(parameters: {\n  data: Hex\n  ccipRequest: (\n    parameters: CcipRequestParameters,\n  ) => Promise<CcipRequestReturnType>\n}): Promise<Hex> {\n  const { data, ccipRequest } = parameters\n\n  const {\n    args: [queries],\n  } = decodeFunctionData({ abi: batchGatewayAbi, data })\n\n  const failures: boolean[] = []\n  const responses: Hex[] = []\n  await Promise.all(\n    queries.map(async (query, i) => {\n      try {\n        responses[i] = query.urls.includes(localBatchGatewayUrl)\n          ? await localBatchGatewayRequest({ data: query.data, ccipRequest })\n          : await ccipRequest(query)\n        failures[i] = false\n      } catch (err) {\n        failures[i] = true\n        responses[i] = encodeError(err as CcipRequestErrorType)\n      }\n    }),\n  )\n\n  return encodeFunctionResult({\n    abi: batchGatewayAbi,\n    functionName: 'query',\n    result: [failures, responses],\n  })\n}\n\nfunction encodeError(error: CcipRequestErrorType): Hex {\n  if (error.name === 'HttpRequestError' && error.status)\n    return encodeErrorResult({\n      abi: batchGatewayAbi,\n      errorName: 'HttpError',\n      args: [error.status, error.shortMessage],\n    })\n  return encodeErrorResult({\n    abi: [solidityError],\n    errorName: 'Error',\n    args: ['shortMessage' in error ? error.shortMessage : error.message],\n  })\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4,5]}