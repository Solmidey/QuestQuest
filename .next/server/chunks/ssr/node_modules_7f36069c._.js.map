{"version":3,"sources":["../../../../node_modules/viem/utils/getAction.ts","../../../../node_modules/%40noble/hashes/src/sha256.ts","../../../../node_modules/viem/utils/errors/getContractError.ts","../../../../node_modules/viem/utils/ens/encodeLabelhash.ts","../../../../node_modules/viem/utils/ens/namehash.ts","../../../../node_modules/viem/utils/ens/errors.ts","../../../../node_modules/viem/utils/ens/encodedLabelToLabelhash.ts","../../../../node_modules/viem/utils/ens/labelhash.ts","../../../../node_modules/viem/utils/ens/packetToBytes.ts","../../../../node_modules/viem/errors/ens.ts","../../../../node_modules/viem/actions/ens/getEnsResolver.ts","../../../../node_modules/viem/actions/ens/getEnsAvatar.ts","../../../../node_modules/viem/actions/public/readContract.ts","../../../../node_modules/viem/actions/ens/getEnsText.ts","../../../../node_modules/viem/actions/ens/getEnsAddress.ts","../../../../node_modules/viem/actions/ens/getEnsName.ts","../../../../node_modules/viem/utils/ens/avatar/utils.ts","../../../../node_modules/%40noble/hashes/src/ripemd160.ts","../../../../node_modules/viem/utils/ens/avatar/parseAvatarRecord.ts","../../../../node_modules/%40noble/hashes/src/legacy.ts","../../../../node_modules/ox/core/Hash.ts"],"sourcesContent":["import type { Client } from '../clients/createClient.js'\nimport type { PublicActions } from '../clients/decorators/public.js'\nimport type { WalletActions } from '../clients/decorators/wallet.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { Account } from '../types/account.js'\nimport type { Chain } from '../types/chain.js'\nimport type { RpcSchema } from '../types/eip1193.js'\n\n/**\n * Retrieves and returns an action from the client (if exists), and falls\n * back to the tree-shakable action.\n *\n * Useful for extracting overridden actions from a client (ie. if a consumer\n * wants to override the `sendTransaction` implementation).\n */\nexport function getAction<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  rpcSchema extends RpcSchema | undefined,\n  extended extends { [key: string]: unknown },\n  client extends Client<transport, chain, account, rpcSchema, extended>,\n  parameters,\n  returnType,\n>(\n  client: client,\n  actionFn: (_: any, parameters: parameters) => returnType,\n  // Some minifiers drop `Function.prototype.name`, or replace it with short letters,\n  // meaning that `actionFn.name` will not always work. For that case, the consumer\n  // needs to pass the name explicitly.\n  name: keyof PublicActions | keyof WalletActions | (string & {}),\n): (parameters: parameters) => returnType {\n  const action_implicit = client[actionFn.name]\n  if (typeof action_implicit === 'function')\n    return action_implicit as (params: parameters) => returnType\n\n  const action_explicit = client[name]\n  if (typeof action_explicit === 'function')\n    return action_explicit as (params: parameters) => returnType\n\n  return (params) => actionFn(client, params)\n}\n","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA224 as SHA224n,\n  sha224 as sha224n,\n  SHA256 as SHA256n,\n  sha256 as sha256n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256: typeof SHA256n = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256: typeof sha256n = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224: typeof SHA224n = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224: typeof sha224n = sha224n;\n","import type { Abi, Address } from 'abitype'\n\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ContractFunctionExecutionError,\n  type ContractFunctionExecutionErrorType,\n  ContractFunctionRevertedError,\n  type ContractFunctionRevertedErrorType,\n  ContractFunctionZeroDataError,\n  type ContractFunctionZeroDataErrorType,\n  RawContractError,\n} from '../../errors/contract.js'\nimport { RpcRequestError } from '../../errors/request.js'\nimport { InternalRpcError, InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\nconst EXECUTION_REVERTED_ERROR_CODE = 3\n\nexport type GetContractErrorReturnType<cause = ErrorType> = Omit<\n  ContractFunctionExecutionErrorType,\n  'cause'\n> & {\n  cause:\n    | cause\n    | ContractFunctionZeroDataErrorType\n    | ContractFunctionRevertedErrorType\n}\n\nexport function getContractError<err extends ErrorType<string>>(\n  err: err,\n  {\n    abi,\n    address,\n    args,\n    docsPath,\n    functionName,\n    sender,\n  }: {\n    abi: Abi\n    args: any\n    address?: Address | undefined\n    docsPath?: string | undefined\n    functionName: string\n    sender?: Address | undefined\n  },\n): GetContractErrorReturnType {\n  const error = (\n    err instanceof RawContractError\n      ? err\n      : err instanceof BaseError\n        ? err.walk((err) => 'data' in (err as Error)) || err.walk()\n        : {}\n  ) as BaseError\n  const { code, data, details, message, shortMessage } =\n    error as RawContractError\n\n  const cause = (() => {\n    if (err instanceof AbiDecodingZeroDataError)\n      return new ContractFunctionZeroDataError({ functionName })\n    if (\n      ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) &&\n        (data || details || message || shortMessage)) ||\n      (code === InvalidInputRpcError.code &&\n        details === 'execution reverted' &&\n        data)\n    ) {\n      return new ContractFunctionRevertedError({\n        abi,\n        data: typeof data === 'object' ? data.data : data,\n        functionName,\n        message:\n          error instanceof RpcRequestError\n            ? details\n            : (shortMessage ?? message),\n      })\n    }\n    return err\n  })()\n\n  return new ContractFunctionExecutionError(cause as BaseError, {\n    abi,\n    args,\n    contractAddress: address,\n    docsPath,\n    functionName,\n    sender,\n  }) as GetContractErrorReturnType\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type EncodeLabelhashErrorType = ErrorType\n\nexport function encodeLabelhash(hash: Hex): `[${string}]` {\n  return `[${hash.slice(2)}]`\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n  type ToBytesErrorType,\n  toBytes,\n} from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type EncodedLabelToLabelhashErrorType,\n  encodedLabelToLabelhash,\n} from './encodedLabelToLabelhash.js'\n\nexport type NamehashErrorType =\n  | BytesToHexErrorType\n  | EncodedLabelToLabelhashErrorType\n  | ToBytesErrorType\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ConcatErrorType\n  | ErrorType\n\n/**\n * @description Hashes ENS name\n *\n * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @example\n * namehash('wevm.eth')\n * '0x08c85f2f4059e930c45a6aeff9dcd3bd95dc3c5c1cddef6a0626b31152248560'\n *\n * @link https://eips.ethereum.org/EIPS/eip-137\n */\nexport function namehash(name: string) {\n  let result = new Uint8Array(32).fill(0) as ByteArray\n  if (!name) return bytesToHex(result)\n\n  const labels = name.split('.')\n  // Iterate in reverse order building up hash\n  for (let i = labels.length - 1; i >= 0; i -= 1) {\n    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i])\n    const hashed = hashFromEncodedLabel\n      ? toBytes(hashFromEncodedLabel)\n      : keccak256(stringToBytes(labels[i]), 'bytes')\n    result = keccak256(concat([result, hashed]), 'bytes')\n  }\n\n  return bytesToHex(result)\n}\n","import { BaseError } from '../../errors/base.js'\nimport { ContractFunctionRevertedError } from '../../errors/contract.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\n/** @internal */\nexport type IsNullUniversalResolverErrorErrorType = ErrorType\n\n/*\n * @description Checks if error is a valid null result UniversalResolver error\n */\nexport function isNullUniversalResolverError(err: unknown): boolean {\n  if (!(err instanceof BaseError)) return false\n  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError)\n  if (!(cause instanceof ContractFunctionRevertedError)) return false\n\n  if (cause.data?.errorName === 'HttpError') return true\n  if (cause.data?.errorName === 'ResolverError') return true\n  if (cause.data?.errorName === 'ResolverNotContract') return true\n  if (cause.data?.errorName === 'ResolverNotFound') return true\n  if (cause.data?.errorName === 'ReverseAddressMismatch') return true\n  if (cause.data?.errorName === 'UnsupportedResolverProfile') return true\n\n  return false\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\n\nexport type EncodedLabelToLabelhashErrorType = IsHexErrorType | ErrorType\n\nexport function encodedLabelToLabelhash(label: string): Hex | null {\n  if (label.length !== 66) return null\n  if (label.indexOf('[') !== 0) return null\n  if (label.indexOf(']') !== 65) return null\n  const hash = `0x${label.slice(1, 65)}`\n  if (!isHex(hash)) return null\n  return hash\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type EncodedLabelToLabelhashErrorType,\n  encodedLabelToLabelhash,\n} from './encodedLabelToLabelhash.js'\n\nexport type LabelhashErrorType =\n  | BytesToHexErrorType\n  | EncodedLabelToLabelhashErrorType\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\n/**\n * @description Hashes ENS label\n *\n * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @example\n * labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n */\nexport function labelhash(label: string) {\n  const result = new Uint8Array(32).fill(0)\n  if (!label) return bytesToHex(result)\n  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label))\n}\n","// Adapted from https://github.com/mafintosh/dns-packet\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray } from '../../types/misc.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport {\n  type EncodeLabelhashErrorType,\n  encodeLabelhash,\n} from './encodeLabelhash.js'\nimport { type LabelhashErrorType, labelhash } from './labelhash.js'\n\nexport type PacketToBytesErrorType =\n  | EncodeLabelhashErrorType\n  | LabelhashErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\n/*\n * @description Encodes a DNS packet into a ByteArray containing a UDP payload.\n *\n * @example\n * packetToBytes('awkweb.eth')\n * '0x0661776b7765620365746800'\n *\n * @see https://docs.ens.domains/resolution/names#dns\n *\n */\nexport function packetToBytes(packet: string): ByteArray {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, '')\n  if (value.length === 0) return new Uint8Array(1)\n\n  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2)\n\n  let offset = 0\n  const list = value.split('.')\n  for (let i = 0; i < list.length; i++) {\n    let encoded = stringToBytes(list[i])\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255)\n      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])))\n    bytes[offset] = encoded.length\n    bytes.set(encoded, offset + 1)\n    offset += encoded.length + 1\n  }\n\n  if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1)\n\n  return bytes\n}\n","import { BaseError } from './base.js'\n\nexport type EnsAvatarInvalidMetadataErrorType =\n  EnsAvatarInvalidMetadataError & {\n    name: 'EnsAvatarInvalidMetadataError'\n  }\nexport class EnsAvatarInvalidMetadataError extends BaseError {\n  constructor({ data }: { data: any }) {\n    super(\n      'Unable to extract image from metadata. The metadata may be malformed or invalid.',\n      {\n        metaMessages: [\n          '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',\n          '',\n          `Provided data: ${JSON.stringify(data)}`,\n        ],\n        name: 'EnsAvatarInvalidMetadataError',\n      },\n    )\n  }\n}\n\nexport type EnsAvatarInvalidNftUriErrorType = EnsAvatarInvalidNftUriError & {\n  name: 'EnsAvatarInvalidNftUriError'\n}\nexport class EnsAvatarInvalidNftUriError extends BaseError {\n  constructor({ reason }: { reason: string }) {\n    super(`ENS NFT avatar URI is invalid. ${reason}`, {\n      name: 'EnsAvatarInvalidNftUriError',\n    })\n  }\n}\n\nexport type EnsAvatarUriResolutionErrorType = EnsAvatarUriResolutionError & {\n  name: 'EnsAvatarUriResolutionError'\n}\nexport class EnsAvatarUriResolutionError extends BaseError {\n  constructor({ uri }: { uri: string }) {\n    super(\n      `Unable to resolve ENS avatar URI \"${uri}\". The URI may be malformed, invalid, or does not respond with a valid image.`,\n      { name: 'EnsAvatarUriResolutionError' },\n    )\n  }\n}\n\nexport type EnsAvatarUnsupportedNamespaceErrorType =\n  EnsAvatarUnsupportedNamespaceError & {\n    name: 'EnsAvatarUnsupportedNamespaceError'\n  }\nexport class EnsAvatarUnsupportedNamespaceError extends BaseError {\n  constructor({ namespace }: { namespace: string }) {\n    super(\n      `ENS NFT avatar namespace \"${namespace}\" is not supported. Must be \"erc721\" or \"erc1155\".`,\n      { name: 'EnsAvatarUnsupportedNamespaceError' },\n    )\n  }\n}\n\nexport type EnsInvalidChainIdErrorType = EnsInvalidChainIdError & {\n  name: 'EnsInvalidChainIdError'\n}\nexport class EnsInvalidChainIdError extends BaseError {\n  constructor({ chainId }: { chainId: number }) {\n    super(\n      `Invalid ENSIP-11 chainId: ${chainId}. Must be between 0 and 0x7fffffff, or 1.`,\n      {\n        name: 'EnsInvalidChainIdError',\n      },\n    )\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsResolverParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Name to get the address for. */\n    name: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsResolverReturnType = Address\n\nexport type GetEnsResolverErrorType =\n  | GetChainContractAddressErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | ErrorType\n\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsResolverParameters,\n): Promise<GetEnsResolverReturnType> {\n  const { blockNumber, blockTag, name } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld)))\n    throw new Error(\n      `${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain \"${chain.name}\" (id: ${chain.id}).`,\n    )\n\n  const [resolverAddress] = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address: universalResolverAddress,\n    abi: [\n      {\n        inputs: [{ type: 'bytes' }],\n        name: 'findResolver',\n        outputs: [\n          { type: 'address' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n      },\n    ],\n    functionName: 'findResolver',\n    args: [toHex(packetToBytes(name))],\n    blockNumber,\n    blockTag,\n  })\n  return resolverAddress\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../types/ens.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type ParseAvatarRecordErrorType,\n  parseAvatarRecord,\n} from '../../utils/ens/avatar/parseAvatarRecord.js'\nimport { getAction } from '../../utils/getAction.js'\n\nimport {\n  type GetEnsTextErrorType,\n  type GetEnsTextParameters,\n  getEnsText,\n} from './getEnsText.js'\n\nexport type GetEnsAvatarParameters = Prettify<\n  Omit<GetEnsTextParameters, 'key'> & {\n    /** Gateway urls to resolve IPFS and/or Arweave assets. */\n    assetGatewayUrls?: AssetGatewayUrls | undefined\n  }\n>\n\nexport type GetEnsAvatarReturnType = string | null\n\nexport type GetEnsAvatarErrorType =\n  | GetEnsTextErrorType\n  | ParseAvatarRecordErrorType\n  | ErrorType\n\n/**\n * Gets the avatar of an ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAvatarParameters}\n * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAvatar, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAvatar = await getEnsAvatar(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'\n */\nexport async function getEnsAvatar<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    assetGatewayUrls,\n    name,\n    gatewayUrls,\n    strict,\n    universalResolverAddress,\n  }: GetEnsAvatarParameters,\n): Promise<GetEnsAvatarReturnType> {\n  const record = await getAction(\n    client,\n    getEnsText,\n    'getEnsText',\n  )({\n    blockNumber,\n    blockTag,\n    key: 'avatar',\n    name,\n    universalResolverAddress,\n    gatewayUrls,\n    strict,\n  })\n  if (!record) return null\n  try {\n    return await parseAvatarRecord(client, {\n      record,\n      gatewayUrls: assetGatewayUrls,\n    })\n  } catch {\n    return null\n  }\n}\n","import type { Abi } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ContractFunctionReturnType,\n} from '../../types/contract.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport { getAction } from '../../utils/getAction.js'\n\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type ReadContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = UnionEvaluate<\n  Pick<\n    CallParameters,\n    | 'account'\n    | 'authorizationList'\n    | 'blockNumber'\n    | 'blockOverrides'\n    | 'blockTag'\n    | 'factory'\n    | 'factoryData'\n    | 'stateOverride'\n  >\n> &\n  ContractFunctionParameters<abi, 'pure' | 'view', functionName, args, boolean>\n\nexport type ReadContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ContractFunctionReturnType<abi, 'pure' | 'view', functionName, args>\n\nexport type ReadContractErrorType = GetContractErrorReturnType<\n  CallErrorType | EncodeFunctionDataErrorType | DecodeFunctionResultErrorType\n>\n\n/**\n * Calls a read-only function on a contract, and returns the response.\n *\n * - Docs: https://viem.sh/docs/contract/readContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_reading-contracts\n *\n * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link ReadContractParameters}\n * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { readContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await readContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),\n *   functionName: 'balanceOf',\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // 424122n\n */\nexport async function readContract<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n>(\n  client: Client<Transport, chain>,\n  parameters: ReadContractParameters<abi, functionName, args>,\n): Promise<ReadContractReturnType<abi, functionName, args>> {\n  const { abi, address, args, functionName, ...rest } =\n    parameters as ReadContractParameters\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n  try {\n    const { data } = await getAction(\n      client,\n      call,\n      'call',\n    )({\n      ...(rest as CallParameters),\n      data: calldata,\n      to: address!,\n    })\n    return decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    }) as ReadContractReturnType<abi, functionName>\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/readContract',\n      functionName,\n    })\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  textResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsTextParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** ENS name to get Text for. */\n    name: string\n    /** Universal Resolver gateway URLs to use for resolving CCIP-read requests. */\n    gatewayUrls?: string[] | undefined\n    /** Text record to retrieve. */\n    key: string\n    /** Whether or not to throw errors propagated from the ENS Universal Resolver Contract. */\n    strict?: boolean | undefined\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsTextReturnType = string | null\n\nexport type GetEnsTextErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | EncodeFunctionDataErrorType\n  | NamehashErrorType\n  | DecodeFunctionResultErrorType\n\n/**\n * Gets a text record for specified ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsTextParameters}\n * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsText, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const twitterRecord = await getEnsText(client, {\n *   name: normalize('wevm.eth'),\n *   key: 'com.twitter',\n * })\n * // 'wevm_dev'\n */\nexport async function getEnsText<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsTextParameters,\n): Promise<GetEnsTextReturnType> {\n  const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld))) return null\n\n  try {\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      args: [\n        toHex(packetToBytes(name)),\n        encodeFunctionData({\n          abi: textResolverAbi,\n          functionName: 'text',\n          args: [namehash(name), key],\n        }),\n        gatewayUrls ?? [localBatchGatewayUrl],\n      ],\n      functionName: 'resolveWithGateways',\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const res = await readContractAction(readContractParameters)\n\n    if (res[0] === '0x') return null\n\n    const record = decodeFunctionResult({\n      abi: textResolverAbi,\n      functionName: 'text',\n      data: res[0],\n    })\n\n    return record === '' ? null : record\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err)) return null\n    throw err\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  addressResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type TrimErrorType, trim } from '../../utils/data/trim.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsAddressParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /**\n     * ENSIP-9 compliant coinType (chain) to get ENS address for.\n     *\n     * To get the `coinType` for a chain id, use the `toCoinType` function:\n     * ```ts\n     * import { toCoinType } from 'viem'\n     * import { base } from 'viem/chains'\n     *\n     * const coinType = toCoinType(base.id)\n     * ```\n     *\n     * @default 60n\n     */\n    coinType?: bigint | undefined\n    /**\n     * Universal Resolver gateway URLs to use for resolving CCIP-read requests.\n     */\n    gatewayUrls?: string[] | undefined\n    /**\n     * Name to get the address for.\n     */\n    name: string\n    /**\n     * Whether or not to throw errors propagated from the ENS Universal Resolver Contract.\n     */\n    strict?: boolean | undefined\n    /**\n     * Address of ENS Universal Resolver Contract.\n     */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsAddressReturnType = Address | null\n\nexport type GetEnsAddressErrorType =\n  | GetChainContractAddressErrorType\n  | EncodeFunctionDataErrorType\n  | NamehashErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | DecodeFunctionResultErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsAddressParameters,\n): Promise<GetEnsAddressReturnType> {\n  const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } =\n    parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld))) return null\n\n  const args = (() => {\n    if (coinType != null) return [namehash(name), BigInt(coinType)] as const\n    return [namehash(name)] as const\n  })()\n\n  try {\n    const functionData = encodeFunctionData({\n      abi: addressResolverAbi,\n      functionName: 'addr',\n      args,\n    })\n\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolveWithGateways',\n      args: [\n        toHex(packetToBytes(name)),\n        functionData,\n        gatewayUrls ?? [localBatchGatewayUrl],\n      ],\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const res = await readContractAction(readContractParameters)\n\n    if (res[0] === '0x') return null\n\n    const address = decodeFunctionResult({\n      abi: addressResolverAbi,\n      args,\n      functionName: 'addr',\n      data: res[0],\n    })\n\n    if (address === '0x') return null\n    if (trim(address) === '0x00') return null\n    return address\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err)) return null\n    throw err\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { universalResolverReverseAbi } from '../../constants/abis.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport type { PacketToBytesErrorType } from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsNameParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /**\n     * Address to get ENS name for.\n     */\n    address: Address\n    /**\n     * ENSIP-9 compliant coinType (chain) to get ENS name for.\n     *\n     * To get the `coinType` for a chain id, use the `toCoinType` function:\n     * ```ts\n     * import { toCoinType } from 'viem'\n     * import { base } from 'viem/chains'\n     *\n     * const coinType = toCoinType(base.id)\n     * ```\n     *\n     * @default 60n\n     */\n    coinType?: bigint | undefined\n    /**\n     * Universal Resolver gateway URLs to use for resolving CCIP-read requests.\n     */\n    gatewayUrls?: string[] | undefined\n    /**\n     * Whether or not to throw errors propagated from the ENS Universal Resolver Contract.\n     */\n    strict?: boolean | undefined\n    /**\n     * Address of ENS Universal Resolver Contract.\n     */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsNameReturnType = string | null\n\nexport type GetEnsNameErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | PacketToBytesErrorType\n  | ErrorType\n\n/**\n * Gets primary name for specified address.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsName\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `reverse(bytes)` on ENS Universal Resolver Contract to \"reverse resolve\" the address to the primary ENS name.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsNameParameters}\n * @returns Name or `null` if not found. {@link GetEnsNameReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsName } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensName = await getEnsName(client, {\n *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',\n * })\n * // 'wevm.eth'\n */\nexport async function getEnsName<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsNameParameters,\n): Promise<GetEnsNameReturnType> {\n  const {\n    address,\n    blockNumber,\n    blockTag,\n    coinType = 60n,\n    gatewayUrls,\n    strict,\n  } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  try {\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverReverseAbi,\n      args: [address, coinType, gatewayUrls ?? [localBatchGatewayUrl]],\n      functionName: 'reverseWithGateways',\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const [name] = await readContractAction(readContractParameters)\n\n    return name || null\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err)) return null\n    throw err\n  }\n}\n","import type { Address } from 'abitype'\n\nimport {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport {\n  EnsAvatarInvalidMetadataError,\n  type EnsAvatarInvalidMetadataErrorType,\n  EnsAvatarInvalidNftUriError,\n  type EnsAvatarInvalidNftUriErrorType,\n  EnsAvatarUnsupportedNamespaceError,\n  type EnsAvatarUnsupportedNamespaceErrorType,\n  EnsAvatarUriResolutionError,\n  type EnsAvatarUriResolutionErrorType,\n} from '../../../errors/ens.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\ntype UriItem = {\n  uri: string\n  isOnChain: boolean\n  isEncoded: boolean\n}\n\nconst networkRegex =\n  /(?<protocol>https?:\\/\\/[^/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/\nconst ipfsHashRegex =\n  /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/\n\ntype IsImageUriErrorType = ErrorType\n\n/** @internal */\nexport async function isImageUri(uri: string) {\n  try {\n    const res = await fetch(uri, { method: 'HEAD' })\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get('content-type')\n      return contentType?.startsWith('image/')\n    }\n    return false\n  } catch (error: any) {\n    // if error is not cors related then fail\n    if (typeof error === 'object' && typeof error.response !== 'undefined') {\n      return false\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    if (!Object.hasOwn(globalThis, 'Image')) return false\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise((resolve) => {\n      const img = new Image()\n      img.onload = () => {\n        resolve(true)\n      }\n      img.onerror = () => {\n        resolve(false)\n      }\n      img.src = uri\n    })\n  }\n}\n\ntype GetGatewayErrorType = ErrorType\n\n/** @internal */\nexport function getGateway(custom: string | undefined, defaultGateway: string) {\n  if (!custom) return defaultGateway\n  if (custom.endsWith('/')) return custom.slice(0, -1)\n  return custom\n}\n\nexport type ResolveAvatarUriErrorType =\n  | GetGatewayErrorType\n  | EnsAvatarUriResolutionErrorType\n  | ErrorType\n\nexport function resolveAvatarUri({\n  uri,\n  gatewayUrls,\n}: {\n  uri: string\n  gatewayUrls?: AssetGatewayUrls | undefined\n}): UriItem {\n  const isEncoded = base64Regex.test(uri)\n  if (isEncoded) return { uri, isOnChain: true, isEncoded }\n\n  const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io')\n  const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net')\n\n  const networkRegexMatch = uri.match(networkRegex)\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = '',\n  } = networkRegexMatch?.groups || {}\n\n  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/'\n  const isIPFS =\n    protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri)\n\n  if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n    let replacedUri = uri\n    if (gatewayUrls?.arweave)\n      replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls?.arweave)\n    return { uri: replacedUri, isOnChain: false, isEncoded: false }\n  }\n\n  if ((isIPNS || isIPFS) && target) {\n    return {\n      uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  if (protocol === 'ar:/' && target) {\n    return {\n      uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  let parsedUri = uri.replace(dataURIRegex, '')\n  if (parsedUri.startsWith('<svg')) {\n    // if svg, base64 encode\n    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`\n  }\n\n  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n    return {\n      uri: parsedUri,\n      isOnChain: true,\n      isEncoded: false,\n    }\n  }\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\nexport type GetJsonImageErrorType =\n  | EnsAvatarInvalidMetadataErrorType\n  | ErrorType\n\nexport function getJsonImage(data: any) {\n  // validation check for json data, must include one of theses properties\n  if (\n    typeof data !== 'object' ||\n    (!('image' in data) && !('image_url' in data) && !('image_data' in data))\n  ) {\n    throw new EnsAvatarInvalidMetadataError({ data })\n  }\n\n  return data.image || data.image_url || data.image_data\n}\n\nexport type GetMetadataAvatarUriErrorType =\n  | EnsAvatarUriResolutionErrorType\n  | ParseAvatarUriErrorType\n  | GetJsonImageErrorType\n  | ErrorType\n\nexport async function getMetadataAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  try {\n    const res = await fetch(uri).then((res) => res.json())\n    const image = await parseAvatarUri({\n      gatewayUrls,\n      uri: getJsonImage(res),\n    })\n    return image\n  } catch {\n    throw new EnsAvatarUriResolutionError({ uri })\n  }\n}\n\nexport type ParseAvatarUriErrorType =\n  | ResolveAvatarUriErrorType\n  | IsImageUriErrorType\n  | EnsAvatarUriResolutionErrorType\n  | ErrorType\n\nexport async function parseAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls })\n  if (isOnChain) return resolvedURI\n\n  // check if resolvedURI is an image, if it is return the url\n  const isImage = await isImageUri(resolvedURI)\n  if (isImage) return resolvedURI\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\ntype ParsedNft = {\n  chainID: number\n  namespace: string\n  contractAddress: Address\n  tokenID: string\n}\n\nexport type ParseNftUriErrorType = EnsAvatarInvalidNftUriErrorType | ErrorType\n\nexport function parseNftUri(uri_: string): ParsedNft {\n  let uri = uri_\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith('did:nft:')) {\n    // convert DID to CAIP\n    uri = uri.replace('did:nft:', '').replace(/_/g, '/')\n  }\n\n  const [reference, asset_namespace, tokenID] = uri.split('/')\n  const [eip_namespace, chainID] = reference.split(':')\n  const [erc_namespace, contractAddress] = asset_namespace.split(':')\n\n  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' })\n  if (!chainID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' })\n  if (!contractAddress)\n    throw new EnsAvatarInvalidNftUriError({\n      reason: 'Contract address not found',\n    })\n  if (!tokenID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' })\n  if (!erc_namespace)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' })\n\n  return {\n    chainID: Number.parseInt(chainID, 10),\n    namespace: erc_namespace.toLowerCase(),\n    contractAddress: contractAddress as Address,\n    tokenID,\n  }\n}\n\nexport type GetNftTokenUriErrorType =\n  | ReadContractErrorType\n  | EnsAvatarUnsupportedNamespaceErrorType\n  | ErrorType\n\nexport async function getNftTokenUri<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { nft }: { nft: ParsedNft },\n) {\n  if (nft.namespace === 'erc721') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'tokenURI',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: 'tokenId', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'tokenURI',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  if (nft.namespace === 'erc1155') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'uri',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: '_id', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'uri',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace })\n}\n","/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\nimport { RIPEMD160 as RIPEMD160n, ripemd160 as ripemd160n } from './legacy.ts';\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const RIPEMD160: typeof RIPEMD160n = RIPEMD160n;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const ripemd160: typeof ripemd160n = ripemd160n;\n","import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\nimport {\n  type GetJsonImageErrorType,\n  type GetMetadataAvatarUriErrorType,\n  type GetNftTokenUriErrorType,\n  getJsonImage,\n  getMetadataAvatarUri,\n  getNftTokenUri,\n  type ParseAvatarUriErrorType,\n  type ParseNftUriErrorType,\n  parseAvatarUri,\n  parseNftUri,\n  type ResolveAvatarUriErrorType,\n  resolveAvatarUri,\n} from './utils.js'\n\nexport type ParseAvatarRecordErrorType =\n  | ParseNftAvatarUriErrorType\n  | ParseAvatarUriErrorType\n  | ErrorType\n\n/*\n * @description Parses an ENS avatar record.\n *\n * @example\n * parseAvatarRecord('eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063')\n * 'https://ipfs.io/ipfs/QmSP4nq9fnN9dAiCj42ug9Wa79rqmQerZXZch82VqpiH7U/image.gif'\n *\n * @see https://docs.ens.domains/web/avatars\n *\n */\nexport async function parseAvatarRecord<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls | undefined\n    record: string\n  },\n): Promise<string> {\n  if (/eip155:/i.test(record))\n    return parseNftAvatarUri(client, { gatewayUrls, record })\n  return parseAvatarUri({ uri: record, gatewayUrls })\n}\n\ntype ParseNftAvatarUriErrorType =\n  | ParseNftUriErrorType\n  | GetNftTokenUriErrorType\n  | ResolveAvatarUriErrorType\n  | ParseAvatarUriErrorType\n  | GetJsonImageErrorType\n  | GetMetadataAvatarUriErrorType\n  | ErrorType\n\nasync function parseNftAvatarUri<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls | undefined\n    record: string\n  },\n): Promise<string> {\n  // parse NFT URI into properties\n  const nft = parseNftUri(record)\n  // fetch tokenURI from the NFT contract\n  const nftUri = await getNftTokenUri(client, { nft })\n  // resolve the URI from the fetched tokenURI\n  const {\n    uri: resolvedNftUri,\n    isOnChain,\n    isEncoded,\n  } = resolveAvatarUri({ uri: nftUri, gatewayUrls })\n\n  // if the resolved URI is on chain, return the data\n  if (\n    isOnChain &&\n    (resolvedNftUri.includes('data:application/json;base64,') ||\n      resolvedNftUri.startsWith('{'))\n  ) {\n    const encodedJson = isEncoded\n      ? // if it is encoded, decode it\n        atob(resolvedNftUri.replace('data:application/json;base64,', ''))\n      : // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)\n        resolvedNftUri\n\n    const decoded = JSON.parse(encodedJson)\n    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls })\n  }\n\n  let uriTokenId = nft.tokenID\n  if (nft.namespace === 'erc1155')\n    uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0')\n\n  return getMetadataAvatarUri({\n    gatewayUrls,\n    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),\n  })\n}\n","/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, clean, createHasher, rotl } from './utils.ts';\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD<SHA1> {\n  private A = SHA1_IV[0] | 0;\n  private B = SHA1_IV[1] | 0;\n  private C = SHA1_IV[2] | 0;\n  private D = SHA1_IV[3] | 0;\n  private E = SHA1_IV[4] | 0;\n\n  constructor() {\n    super(64, 20, 8, false);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { A, B, C, D, E } = this;\n    return [A, B, C, D, E];\n  }\n  protected set(A: number, B: number, C: number, D: number, E: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++)\n      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let { A, B, C, D, E } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    this.set(A, B, C, D, E);\n  }\n  protected roundClean(): void {\n    clean(SHA1_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1: CHash = /* @__PURE__ */ createHasher(() => new SHA1());\n\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) =>\n  Math.floor(p32 * Math.abs(Math.sin(i + 1)))\n);\n\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD<MD5> {\n  private A = MD5_IV[0] | 0;\n  private B = MD5_IV[1] | 0;\n  private C = MD5_IV[2] | 0;\n  private D = MD5_IV[3] | 0;\n\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      let F, g, s;\n      if (i < 16) {\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean(): void {\n    clean(MD5_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5: CHash = /* @__PURE__ */ createHasher(() => new MD5());\n\n// RIPEMD-160\n\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n  const L = [Id160];\n  const R = [Pi160];\n  const res = [L, R];\n  for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map((k) => Rho160[k]));\n  return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\n\nconst shifts160 = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  if (group === 1) return (x & y) | (~x & z);\n  if (group === 2) return (x | ~y) ^ z;\n  if (group === 3) return (x & z) | (y & ~z);\n  return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean(): void {\n    clean(BUF_160);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160: CHash = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n","import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160'\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3'\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: keccak256.Options<as> = {},\n): keccak256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_keccak256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace keccak256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: ripemd160.Options<as> = {},\n): ripemd160.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_ripemd160(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace ripemd160 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: sha256.Options<as> = {},\n): sha256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_sha256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace sha256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value: string): value is Hex.Hex {\n  return Hex.validate(value) && Hex.size(value) === 32\n}\n\nexport declare namespace validate {\n  type ErrorType =\n    | Hex.validate.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n"],"names":[],"mappings":"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oC,CAClC,GADsC,CAAA,CEa/B,OFZO,iBAAiB,EACrC,CGcC,GAAA,CHf2C,CEa1C,AFZI,IGcI,QHdU,UGcU,aHbxC,EAAU,IAAI,EAAE,YAAA,4BACA,YAAA,0BACZ,AADoD,EACpD,IAAA,CAD2D,CDqBnD,ACpBR,YAA0B,6BAGhC,CAAC,OAHoE,yHCdrD,EAAwB,CHAvB,AID4B,ADCQ,CDLP,CCM5C,ECFyE,CHIpE,AGHA,ACKA,AFJgB,ACFoD,CACxB,ACKA,CFJ1B,AFE4B,GEF/C,AEGuB,CDJK,AHGC,AIED,AADL,CFHjB,GAAD,CCDgC,ACKA,CJFE,CAAA,CADd,CEAF,AFAE,CAKN,AELK,EAAE,CFM/B,AENK,CFKJ,CELU,CDP4D,CAAA,CCO7D,CAA4B,AFMhC,GENY,CAAC,GAAG,CAAC,EACK,EAAE,GAAzB,EAAM,OAAO,CAAC,KFKiB,AEPV,CFOU,AAJH,AGDhC,MDFgC,GFGS,CEHL,CFGO,AEA3C,AAHoC,CEI6B,CAAA,EFD3D,EAAO,AFAoC,CGJsB,ADI1D,CCJ0D,AHGE,AEC/D,CAAG,ADEF,ADH8D,EEC5D,CCDU,CDCV,ECAd,GDA8B,CAAA,EAAI,ACA5B,EDA8B,CAAC,CAAA,CAAE,CAAA,MACtC,AAAI,CAAA,EAAA,CAAA,CAAA,KAAA,AAAM,EAAC,GACJ,CADQ,CAAC,ADIP,ICFX,CFuBM,AEvBL,ECcE,ACCA,OJQa,ECnBkD,CAAA,ADmB7B,GGNC,CAAC,CAAA,GHOxB,IAAI,QIL4B,AHdpB,GAAA,IDmBO,IAAA,CAAA,OAC3B,EAAA,MAAA,CAAA,EAAa,EAAA,UAAA,AAAU,EAAC,GCnBJ,GDmBU,CAAC,EAErB,CCrBoD,CDqB/C,CIHF,IJGE,CAAM,EIHE,CJGC,AIHA,CJGC,AIHD,CJGC,AAE9B,IAAK,IAAI,CAAC,CAAG,EAAO,ACtBmD,AGmB1D,CHnB0D,KDsB7C,CAAG,CAAC,CAAA,GAAA,EAAA,GAAe,CAAC,CAAE,CAAC,IACzC,ECrBI,ADqBmB,CCrBnB,CDqB2C,CAAM,CAAC,CAAC,CAAC,CAAC,CAAA,AACzD,EAAS,EAAoB,CAAA,CAAvB,CACR,EIHO,CJCe,EI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iBnB,CHhBd,CKaF,AJLO,AEUA,ACNP,AEPO,GAF4C,CNH5C,AMG4C,CNF/C,ICOY,AEUA,CIIC,CNdC,AEUA,QIbgB,EAElC,2BAA2B,GAE5B,MAAM,wBAAwB,CAAA,MPPzB,CACE,CGiB8C,AELrB,CDDE,CCCA,AFKqB,CCNnB,CGUpB,CDjBC,OAAA,6DCgBuI,CAAA,sCPlB/I,EAAE,CACF,CAAA,SIUmB,EAAE,IJVrB,EKW2B,ADDA,AJV3B,EKW6B,GLXN,GKWY,CGlBF,IAAI,CROL,CAAC,GIWmC,CJX/B,AAAG,CIW4B,AJX9B,AQPS,ARQhD,CACD,CQTmD,EHoBlB,EAAE,ALX7B,EQTmD,CJqBlD,GCDkC,ADEhD,GCJuE,CAAA,EDIjE,GItBuE,CAAC,GHmBG,ADFA,CAAA,ACEA,aLPhF,CAAC,CKQ2E,AISxE,ADzBA,CHgBwE,QGnBf,EJqBtB,CAAA,eJJiB,ISsBA,iBTrB1C,CAAM,CSsBC,CAAA,MTrBd,CAAC,CAAA,+BAAA,EAAkC,EAAM,CAAE,CAAE,CAChD,CAD4C,IACtC,iCAQN,MAAO,GSqCC,OTrCmC,EAAA,SAAS,aAC5C,CAAA,IAAA,CAAK,CAAA,CAAA,4CAEwB,EAAG,6EAAA,CAA+E,CACvH,CAAE,IAAI,CAAE,6BAA6B,CAAE,CACxC,CAAA,CAEJ,AAMK,MAAO,UAA2C,ESmCI,MAAA,GAAA,CTlC1D,YAAY,WAAE,CAAA,CAAkC,CAAA,CAC9C,KAAK,CAAA,CAAA,0BAAA,EAC0B,EAAS,OAAA,2CAAA,CAAoD,CAC1F,CAAE,IAAI,CAAE,oCAAoC,CAAE,CAC/C,CAAA,CAEJ,AAKK,MAAO,CS6BL,AF/BD,SPEqC,EAAA,SAAS,sBACrC,CAAO,CAAuB,CAAA,MACrC,CAAA,CAAA,0BAAA,ES2BmG,AT1BzE,EAAO,CS6BA,CAAC,CAAA,ET7BD,oCAAA,CAA2C,CAC/E,2OOrCA,CNhBC,AIGA,AFOA,ADVA,AIAA,AFEA,CGeL,CJLA,AGZO,AJGP,AGEA,AJHA,AGEA,kIGcI,CHZC,AELA,ADMA,AFOA,AFVA,CMeL,INfwB,AEUA,GGbG,EAAE,CDQN,ADDA,GACxB,ACCA,ECToC,IF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","ignoreList":[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}